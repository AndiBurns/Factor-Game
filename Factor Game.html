<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Factor Game</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
        //This list gets expanded dynamically, and doesn't even require this much seeding.
        var knownPrimes = [2,3,5,7,11,13,17,19];

        function ensureEnoughKnownPrimes(n) {
            //greatest known prime
            var gkp = knownPrimes[knownPrimes.length-1];
            //next potential prime
            var npp = gkp + 1;
        
            while (gkp * gkp < n) {
                //the greatest known prime is less than the square root of n
                //therefore, there may be a greater, as yet unknown, prime that does factor n
                //keep finding primes until we've found one greater than or equal to sqrt(n)
                
                //set this flag indicating that npp is prime (even though we don't yet know that),
                //and then the following loop tries to prove this false.
                let nppIsPrime = true;
                for (let p of knownPrimes) {
                    if (npp % p == 0) {
                        //this "potential" prime isn't prime. Try the next one.
                        nppIsPrime = false;
                        npp++;
                        break;
                    }
                }

                if (nppIsPrime) {
                    //We looped through all previously known primes without finding a factor of npp.
                    //npp is in fact prime. Add it to the list, it is now the greatest known prime,
                    //the next potential prime is the next integer. We're ready to continue the
                    //while loop, and with this new gkp value, potentially terminate this function.
                    knownPrimes.push(npp);
                    gkp = npp;
                    npp++;
                }
            }
        }

        class FactorGame extends React.Component {
            constructor(props) {
                super(props);
                this.state = { number: props.number,
                               digits: props.digits };
            }

            render() {
                return (
                    <div className="factor-game">
                        <h1>Factor Game</h1>
                        <MagicNumber number={this.state.number} digits={this.state.digits}/>
                        <FactorList/>
                    </div>
                );
            }
        }

        function randInt(min,max) {
            return Math.floor(Math.random() * (max - min + 1) ) + min;
        }

        class MagicNumber extends React.Component {
            constructor(props) {
                super(props);

                //minimum always 2. It's gotta be a factorable positive integer.
                //If 1 were allowed, then first player (that is, the comp) would lose. Can't have that.
                var min = 2;
                //no data validation on "digits" implemented. It *should* be a positive integer.
                //1 is a valid value, resulting in a range of 2-9 inclusive for Magic Number
                //The more digits allowed, the larger the possible Magic Number, the more computation required, in general.
                var max = Math.pow(10,props.digits) - 1;

                this.state = { min: min,
                               max: max,
                               number: ( props.number ? props.number : randInt(min,max) )
                             };

                this.onClickUpdate = this.onClickUpdate.bind(this);
                this.registerUpdateModal = this.registerUpdateModal.bind(this);
                this.registerPrimeFactorization = this.registerPrimeFactorization.bind(this);
                this.onClickShowFactorization = this.onClickShowFactorization.bind(this);
            }

            onClickUpdate() {
                this.state.updateModal.show();
            }

            registerUpdateModal(um) {
                this.setState( { updateModal: um } );
            }

            registerPrimeFactorization(pf) {
                this.setState( { primeFactorization: pf } );
            }

            onClickShowFactorization(event) {
                this.state.primeFactorization.show(event.target.checked);
            }

            render() {
                return (
                    <label>
                    <UpdateModal number={this.state.number} parent={this} min={this.state.min} max={this.state.max}/>
                    <div align="center">Magic Number: {this.state.number}</div><br/>
                    <button onClick={this.onClickUpdate}>Change Magic Number</button><p/>
                    <input type="checkbox" onChange={this.onClickShowFactorization}/>Show prime factorization<br/>
                    <PrimeFactorization number={this.state.number} parent={this}/>
                    </label>
                );
            }
        }

        class UpdateModal extends React.Component {
            constructor(props) {

                super(props);

                //Register this child modal with the parent, so that the parent knows where to call to show the modal.
                //Less convoluted way of doing this? Dunno.
                this.props.parent.registerUpdateModal(this);

                this.show = this.show.bind(this);
                this.checkRules = this.checkRules.bind(this);
                this.onChange = this.onChange.bind(this);
                this.randomizeNumber = this.randomizeNumber.bind(this);
                this.changeNumber = this.changeNumber.bind(this);
                this.onConfirm = this.onConfirm.bind(this);
                this.onCancel = this.onCancel.bind(this);
            
                //call checkRules without the state already set. Send it the tentative state. It will return the state
                //as passed, with all of the relevant checkRules data added.
                this.state = this.checkRules( { number: this.props.number,
                                                numberIncoming: this.props.number,
                                                min: this.props.min,
                                                max: this.props.max,
                                                show: false,
                                                parent: parent } );
            }

            show() {
                this.setState( { show: true } );
            }

            checkRules(tentativeState) {
                const n = Number(tentativeState.number);
                const posint = ( Number.isInteger(n) && ( n > 0 ) );
                const satmin = n >= tentativeState.min;
                const satmax = n <= tentativeState.max;

                const satisfiedRuleStyle = {
                    color: 'black'
                }
                const unsatisfiedRuleStyle = {
                    color: 'red'
                }

                const stateUpdates = { rulePositiveIntegerStyle: ( posint ? satisfiedRuleStyle : unsatisfiedRuleStyle ),
                                       ruleMinimumStyle: ( satmin ? satisfiedRuleStyle : unsatisfiedRuleStyle ),
                                       ruleMaximumStyle: ( satmax ? satisfiedRuleStyle : unsatisfiedRuleStyle ),
                                       enableConfirm: ( posint && satmin && satmax ) };

                //There are a lot of ways to do what the following line does. It merges the properties from stateUpdates into
                //tentativeState. This way is ES6 compliant. Earlier versions would probably need to use an "in" loop. Object
                //spread notation (ES 2018) would be nice, but I don't want to rely on the browser supporting that syntax.
                Object.assign(tentativeState, stateUpdates);
                return tentativeState;
            }

            onChange(event) {
                this.changeNumber(event.target.value);
            }

            randomizeNumber() {
                this.changeNumber( randInt( this.state.min, this.state.max ) );
            }

            changeNumber(number) {
                //Create a new object to merge the new number value into the current state. Shouldn't modify current state directly.
                //Merging the current state into an object that already has its number value set to the new value would overwrite
                //that with the old value (which is not desired).
                const tentativeState = Object.assign( {}, this.state, { number: number } );

                //checkRules will add its relevant data to the passed tentativeState. It returns the complete new state.
                this.setState( this.checkRules( tentativeState ) );
            }

            onConfirm() {
                
            }

            onCancel() {
                
            }
            
            render() {
                if(!this.state.show) {
                    return null;
                }

                // The gray background
                const backdropStyle = {
                    position: 'fixed',
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    backgroundColor: 'rgba(0,0,0,0.3)',
                    padding: 50
                };

                // The modal "window"
                const modalStyle = {
                    //allow positioning the footer relative to this
                    position: 'relative',
                    backgroundColor: '#fff',
                    borderRadius: 5,
                    maxWidth: 500,
                    minHeight: 300,
                    margin: '0 auto',
                    padding: 30
                };

                const footerStyle = {
                    //will be positioned relative to modal "window"
                    position: 'absolute',
                    bottom: 20
                }

                const footerButtonStyle = {
                    //Chonky buttons, big ol' clickable areas
                    padding: 10
                }

                return (
                    <div className="backdrop" style={backdropStyle}>
                        <div className="modal" style={modalStyle}>
                            <div>
                                <b>Magic Number</b><br/>
                                <input type="number" value={this.state.number} onChange={this.onChange}/>
                                <button onClick={this.randomizeNumber}>Randomize</button><p/>
                                <div style={this.state.rulePositiveIntegerStyle}>The Magic Number must be a positive integer.</div><br/>
                                <div style={this.state.ruleMinimumStyle}>The Magic Number must be at least {this.state.min}.</div><br/>
                                <div style={this.state.ruleMaximumStyle}>The Magic Number must be at most {this.state.max}.</div><br/>
                            </div>

                            <div className="footer" style={footerStyle}>
                                <b>Confirm</b>ing will start a <b>New Game</b> with Magic Number {this.state.number}<p/>
                                <b>Cancel</b>ing will continue the <b>Current Game</b> with Magic Number {this.state.numberIncoming}<p/>
                                <button onClick={this.onConfirm} style={footerButtonStyle} disabled={!this.state.enableConfirm}>
                                    Confirm
                                </button>
                                <button onClick={this.onCancel} style={footerButtonStyle}>
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }
        }

        class PrimeFactorization extends React.Component {
            constructor(props) {

                super(props);

                props.parent.registerPrimeFactorization(this);

                this.show = this.show.bind(this);

                var n = props.number;
                ensureEnoughKnownPrimes(n);
                var factorization = {};
                for (let p of knownPrimes) {
                    while ( n % p == 0 ) {
                        //while p divides n (once for each time n can be divided by p),
                        //divide p out of n, and note in the factorization object how many times
                        //we were able to do this for p.
                        n /= p;
                        factorization[p] = factorization[p] ? factorization[p] + 1 : 1;
                    }
                }
                if ( n !== 1 ) {
                    //in this case, we've divided out a lot of (known) prime factors, and been left with
                    //a non-1 n value. This must itself be a prime. If it weren't, one of the known primes
                    //(which go up to sqrt(props.number)) would have divided it.
                    factorization[n] = 1;
                }

                this.state = { show: false,
                               factorization: factorization
                             };
            }

            show(s) {
                this.setState( { show: s } );
            }

            render() {
                if (!this.state.show) {
                    return null;
                } else {
                    let s = "";
                    for (let f in this.state.factorization) {
                        if (s) { s += " * "; }
                        s += f + "^" + this.state.factorization[f];
                    }

                    return s;
                }
            }
        }

        class FactorList extends React.Component {
            render() {
                return (
                    "Factors"
                );
            }
        }

      ReactDOM.render(
        <FactorGame digits="6"/>,
        document.getElementById('root')
      );

    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      To set up a production-ready React build environment, follow these instructions:
      * https://reactjs.org/docs/add-react-to-a-new-app.html
      * https://reactjs.org/docs/add-react-to-an-existing-app.html

      You can also use React without JSX, in which case you can remove Babel:
      * https://reactjs.org/docs/react-without-jsx.html
      * https://reactjs.org/docs/cdn-links.html
    -->
  </body>
</html>
